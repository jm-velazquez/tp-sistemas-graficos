<!doctype html>
<html>
    <head>
        <title></title>        
        <style>
            body{ background-color: grey; }
            canvas{ background-color: white; }
			textarea{ background-color: black; foreground-color: white;}
        </style>
    </head>
    <body>

    	<center>    		            
            <canvas id="my-canvas" width="1000" height="800">
            	Your browser does not support the HTML5 canvas element.
    		</canvas>    		
    	</center>
        
        <script id="shader-vs" type="x-shader/x-vertex">

            precision highp float;

            attribute vec3 aVertexPosition;
            attribute vec3 aVertexNormal;

            uniform mat4 modelMatrix;            
            uniform mat4 viewMatrix;
            uniform mat4 projMatrix;

            uniform mat4 normalMatrix;

            varying vec3 vNormal;    
            varying vec3 vPosWorld;  

            void main(void) {
                gl_Position = projMatrix * viewMatrix * modelMatrix * vec4(aVertexPosition, 1.0);

                vPosWorld=(modelMatrix*vec4(aVertexPosition,1.0)).xyz;    //la posicion en coordenadas de mundo
                vNormal=(normalMatrix*vec4(aVertexNormal,1.0)).xyz;       //la normal en coordenadas de mundo                
                
            }
        </script>

        <script id="shader-fs" type="x-shader/x-fragment">
            precision highp float;
            varying vec3 vNormal;
            varying vec3 vPosWorld;

            void main(void) {

                vec3 lightVec=normalize(vec3(0.0,3.0,5.0)-vPosWorld);
                vec3 diffColor=mix(vec3(0.7,0.7,0.7),vNormal,0.4);
                vec3 color=dot(lightVec,vNormal)*diffColor+vec3(0.2,0.2,0.2);

               gl_FragColor = vec4(color,1.0);
            }
        </script>
        
        <script type="text/javascript" src="./js/gl-matrix-min.js"></script>

        <script type="module">
            import { getCar } from "./models/car.js";
            import { getBlock, getBuildingBlockHeights } from "./models/block.js";
            import { getBlockGrid, getBuildingBlockHeightsPerBlock } from "./models/block-grid.js";
            import { drawGrid } from "./models/grid.js";

            let mat4=glMatrix.mat4;
            let vec3=glMatrix.vec3;

            let gl = null;

            let glProgram = null;
            let fragmentShader = null;
            let vertexShader = null;
               
            let modelMatrix = mat4.create();
            let viewMatrix = mat4.create();
            let projMatrix = mat4.create();
            let rotate_angle = -1.57078;
            
            let canvas = document.getElementById("my-canvas");
         
            function initWebGL(){
                try{
                    gl = canvas.getContext("webgl");      

                }catch(e){
                    alert(  "Error: Your browser does not appear to support WebGL.");
                }

                if(gl) {
                    setupWebGL();
                    initShaders();
                    tick();

                }else{    
                    alert(  "Error: Your browser does not appear to support WebGL.");
                }

            }
           

            function setupWebGL(){
                gl.enable(gl.DEPTH_TEST);
                //set the clear color
                gl.clearColor(0.1, 0.1, 0.2, 1.0);     
                gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);     
    
                gl.viewport(0, 0, canvas.width, canvas.height);

                // Matrix de Proyeccion Perspectiva

                mat4.perspective(projMatrix,45, canvas.width / canvas.height, 0.1, null);
                
                mat4.identity(modelMatrix);
                mat4.rotate(modelMatrix,modelMatrix, -1.57078, [1.0, 0.0, 0.0]);

                mat4.identity(viewMatrix);
                mat4.translate(viewMatrix,viewMatrix, [0.0, 0, -1000.0]);
            }
                    
                    
            function initShaders() {
                //get shader source
                var fs_source = document.getElementById('shader-fs').innerHTML,
                    vs_source = document.getElementById('shader-vs').innerHTML;

                //compile shaders    
                vertexShader = makeShader(vs_source, gl.VERTEX_SHADER);
                fragmentShader = makeShader(fs_source, gl.FRAGMENT_SHADER);
                
                //create program
                glProgram = gl.createProgram();
                
                //attach and link shaders to the program
                gl.attachShader(glProgram, vertexShader);
                gl.attachShader(glProgram, fragmentShader);
                gl.linkProgram(glProgram);

                if (!gl.getProgramParameter(glProgram, gl.LINK_STATUS)) {
                    alert("Unable to initialize the shader program.");
                }
                
                //use program
                gl.useProgram(glProgram);
            }
            
            function makeShader(src, type){
                //compile the vertex shader
                var shader = gl.createShader(type);
                gl.shaderSource(shader, src);
                gl.compileShader(shader);

                if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
                    console.log("Error compiling shader: " + gl.getShaderInfoLog(shader));
                }
                return shader;
            }
            
            function tick(){
                requestAnimationFrame(tick);

                createScene();
                animate();
            }

            let previousClientX = 0;
            let previousClientY = 0;
            let radius = 200;
            let alpha = 0;
            let beta = Math.PI / 2;
            let speedFactor = 0.01;

            let plusDown = false;
            let minusDown = false;

            let zoomFactor = -20;

            let actualEvent;

            let mouse = {x: 0, y: 0};

            canvas.addEventListener("mousemove", (e) => {
                mouse.x = e.clientX || e.pageX; 
                mouse.y = e.clientY || e.pageY;
            });

            window.addEventListener("keydown", (e) => {
                if (e.key === "=") plusDown = true;
                else if (e.key === "-")minusDown = true;
            });

            window.addEventListener("keyup", (e) => {
                if (e.key === "=") plusDown = false;
                else if (e.key === "-") minusDown = false;
            });

            function animate() {
                rotateOrbitalCamera();
                zoomInOrbitalCamera();
            }

            function rotateOrbitalCamera() {
                let deltaX = 0;
                let deltaY = 0;

                if (previousClientX) deltaX = mouse.x - previousClientX;
                if (previousClientY) deltaY = mouse.y - previousClientY;

                previousClientX = mouse.x;
                previousClientY = mouse.y;

                alpha = alpha + deltaX * speedFactor;
                beta = beta + deltaY * speedFactor;

                if (beta<0) beta=0;
                if (beta>Math.PI) beta=Math.PI;

                mat4.identity(modelMatrix);
                mat4.translate(
                    modelMatrix,
                    modelMatrix,
                    [
                        radius * Math.sin(alpha) * Math.sin(beta),
                        radius * Math.cos(beta),
                        radius * Math.cos(alpha) * Math.sin(beta),
                    ]
                );
            }

            function zoomInOrbitalCamera() {
                if (plusDown) {
                    zoomFactor += 2;
                    if (zoomFactor > -100) zoomFactor = -100;
                } else if (minusDown) {
                    zoomFactor -= 2;
                    if (zoomFactor < -1000) zoomFactor = -1000;
                }

                mat4.identity(viewMatrix);
                mat4.translate(viewMatrix,viewMatrix, [0, 0, zoomFactor]);
            }

            const buildingHeightsPerBlock = getBuildingBlockHeightsPerBlock();

            function createScene() {
                drawGrid(gl, glMatrix, glProgram, modelMatrix, viewMatrix, projMatrix);

                const car = getCar(gl, glMatrix);
                // car.draw(gl, glMatrix, glProgram, modelMatrix, viewMatrix, projMatrix);
                const blockGrid = getBlockGrid(gl, glMatrix, buildingHeightsPerBlock);
                blockGrid.draw(gl, glMatrix, glProgram, modelMatrix, viewMatrix, projMatrix);
            }

            window.onload=initWebGL;

        </script>


    </body>
</html>
