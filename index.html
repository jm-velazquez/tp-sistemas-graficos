<!doctype html>
<html>
    <head>
        <title></title>        
        <style>
            body{ background-color: grey; }
            canvas{ background-color: white; }
			textarea{ background-color: black; }
        </style>
        <link rel="stylesheet" type="text/css" href="curve-editor/curve-editor.css">
    </head>
    <body>
		<center> 
            <canvas id="my-canvas" width="1000" height="700">
            	Your browser does not support the HTML5 canvas element.
    		</canvas>
        </center>
        <div id="editor-container"></div>
        
        <script id="shader-vs" type="x-shader/x-vertex">

            precision highp float;

            attribute vec3 aVertexPosition;
            attribute vec3 aVertexNormal;

            uniform mat4 modelMatrix;            
            uniform mat4 viewMatrix;
            uniform mat4 projMatrix;

            uniform mat4 normalMatrix;

            varying vec3 vNormal;    
            varying vec3 vPosWorld;  

            void main(void) {
                gl_Position = projMatrix * viewMatrix * modelMatrix * vec4(aVertexPosition, 1.0);

                vPosWorld=(modelMatrix*vec4(aVertexPosition,1.0)).xyz;    //la posicion en coordenadas de mundo
                vNormal=(normalMatrix*vec4(aVertexNormal,1.0)).xyz;       //la normal en coordenadas de mundo                
                
            }
        </script>

        <script id="shader-fs" type="x-shader/x-fragment">
            precision highp float;
            varying vec3 vNormal;
            varying vec3 vPosWorld;

            void main(void) {

                vec3 lightVec=normalize(vec3(500.0,500.0,200.0)-vPosWorld);
                vec3 diffColor=mix(vec3(0.7,0.7,0.7),vNormal,0.4);
                vec3 color=dot(lightVec,vNormal)*diffColor+vec3(0.2,0.2,0.2);

               gl_FragColor = vec4(color,1.0);
            }
        </script>
        
        <script type="text/javascript" src="./js/gl-matrix-min.js"></script>
        <script type="text/javascript" src="./js/dat.gui.min.js"></script>

        <script type="module">
            import { getCar } from "./models/car.js";
            import { getHighway } from "./models/highway.js";
            import { getBlock, getBuildingBlockHeights } from "./models/block.js";
            import { getBlockGrid, getBuildingBlockHeightsPerBlock, getEmptyGrids } from "./models/block-grid.js";
            import { drawGrid } from "./models/grid.js";
            import { OrbitalCamera } from "./cameras/orbital-camera.js";
            import { CurveEditor } from "./curve-editor/curve-editor.js";
            import { Bezier2 } from "./curves/bezier.js";
            
            const CURVE_EDITOR_SIDE = 300;

            const editor = new CurveEditor(
                "editor-container",
                { width: CURVE_EDITOR_SIDE, height: CURVE_EDITOR_SIDE }
            );
            editor.setControlPoints([[0,0],[300,50],[50,300],[300,300]]);

            let mat4=glMatrix.mat4;
            let vec3=glMatrix.vec3;

            let gl = null;

            let glProgram = null;
            let fragmentShader = null;
            let vertexShader = null;
               
            let modelMatrix = mat4.create();
            let viewMatrix = mat4.create();
            let projMatrix = mat4.create();
            let rotate_angle = -1.57078;
            
            let canvas = document.getElementById("my-canvas");
         
            function initWebGL(){
                try{
                    gl = canvas.getContext("webgl");      

                }catch(e){
                    alert(  "Error: Your browser does not appear to support WebGL.");
                }

                if(gl) {
                    setupWebGL();
                    initShaders();
                    generateSceneParameters();
                    tick();

                }else{    
                    alert(  "Error: Your browser does not appear to support WebGL.");
                }

            }
           

            function setupWebGL(){
                gl.enable(gl.DEPTH_TEST);
                //set the clear color
                gl.clearColor(0.1, 0.1, 0.2, 1.0);     
                gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);     
    
                gl.viewport(0, 0, canvas.width, canvas.height);

                // Matrix de Proyeccion Perspectiva

                mat4.perspective(projMatrix,45, canvas.width / canvas.height, 0.1, null);
                
                mat4.identity(modelMatrix);
            }
                    
                    
            function initShaders() {
                //get shader source
                let fs_source = document.getElementById('shader-fs').innerHTML;
                let vs_source = document.getElementById('shader-vs').innerHTML;

                //compile shaders    
                vertexShader = makeShader(vs_source, gl.VERTEX_SHADER);
                fragmentShader = makeShader(fs_source, gl.FRAGMENT_SHADER);
                
                //create program
                glProgram = gl.createProgram();
                
                //attach and link shaders to the program
                gl.attachShader(glProgram, vertexShader);
                gl.attachShader(glProgram, fragmentShader);
                gl.linkProgram(glProgram);

                if (!gl.getProgramParameter(glProgram, gl.LINK_STATUS)) {
                    alert("Unable to initialize the shader program.");
                }
                
                //use program
                gl.useProgram(glProgram);
            }
            
            function makeShader(src, type){
                //compile the vertex shader
                let shader = gl.createShader(type);
                gl.shaderSource(shader, src);
                gl.compileShader(shader);

                if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
                    console.log("Error compiling shader: " + gl.getShaderInfoLog(shader));
                }
                return shader;
            }
            
            function tick(){
                requestAnimationFrame(tick);

                createScene();
                animate();
            }

            let app = {
                generate: () => {
                    generateSceneParameters();
                },
                showEditor: () => {

                },
                lights: 4,
                pillars: 10,
            };

            function GUI() {
                const gui = new dat.GUI();		

                const f1 = gui.addFolder('Generate');		
                f1.add(app, 'generate').name("Generate Scenery");				
                f1.open();

                const f2 = gui.addFolder('Parameters');
                f2.add(app, 'lights', 4, 25).name("Lights");
                f2.add(app, 'pillars', 4, 25).name("Pillars");
                f2.open();
            };

            const orbitalCamera = new OrbitalCamera();

            canvas.addEventListener("mousemove", (e) => {
                orbitalCamera.setCurrentPosition(e.clientX || e.pageX, e.clientY || e.pageY);
            });

            window.addEventListener("keydown", (e) => {
                if (e.key === "=") orbitalCamera.zoomIn();
                else if (e.key === "-") orbitalCamera.zoomOut();
                else if (e.key === "w") sidewalkCamera.setMovingForward(true);
                else if (e.key === "s") sidewalkCamera.setMovingBack(true);
                else if (e.key === "a") sidewalkCamera.setMovingLeft(true);
                else if (e.key === "d") sidewalkCamera.setMovingRight(true);
            });

            window.addEventListener("keyup", (e) => {
                if (e.key === "w") sidewalkCamera.setMovingForward(false);
                else if (e.key === "s") sidewalkCamera.setMovingBack(false);
                else if (e.key === "a") sidewalkCamera.setMovingLeft(false);
                else if (e.key === "d") sidewalkCamera.setMovingRight(false);
            });

            window.addEventListener("wheel", (e) => {
                if (e.deltaY > 0) orbitalCamera.zoomOut();
                else if (e.deltaY < 0) orbitalCamera.zoomIn();
            });

            function animate() {
                viewMatrix = orbitalCamera.getMatrix(glMatrix);
            }

            let buildingHeightsPerBlock = [];
            let highwayLevels = []; 
            let emptyGrids = [];

            function generateSceneParameters() {
                buildingHeightsPerBlock = getBuildingBlockHeightsPerBlock();
                let controlPoints = editor.getControlPoints();
                controlPoints.unshift(controlPoints[0]);
                controlPoints.push(controlPoints[controlPoints.length -1 ]);
                controlPoints = controlPoints.map(point => [
                    (point[0] - CURVE_EDITOR_SIDE / 2) * (560 / 300),
                    (point[1] - CURVE_EDITOR_SIDE / 2) * (560 / 300),
                ]);
                const bezierCurve = new Bezier2();
                bezierCurve.setControlPoints(controlPoints);
                highwayLevels = bezierCurve.getPolygon();
                emptyGrids = getEmptyGrids(highwayLevels);
            }

            function createScene() {
                drawGrid(gl, glMatrix, glProgram, modelMatrix, viewMatrix, projMatrix);

                const car = getCar(gl, glMatrix);
                // car.draw(gl, glMatrix, glProgram, modelMatrix, viewMatrix, projMatrix);
                const blockGrid = getBlockGrid(gl, glMatrix, buildingHeightsPerBlock, emptyGrids);
                blockGrid.draw(gl, glMatrix, glProgram, modelMatrix, viewMatrix, projMatrix);

                const highway = getHighway(gl, glMatrix, highwayLevels);
                highway.rotationAxis = [1, 0, 0];
                highway.rotationDegree = Math.PI  / 2;
                highway.translationVector = [0, 0, 30];
                highway.draw(gl, glMatrix, glProgram, modelMatrix, viewMatrix, projMatrix);
            }
            GUI();
            window.onload=initWebGL;

        </script>


    </body>
</html>
